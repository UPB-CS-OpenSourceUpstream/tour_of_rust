- title: Capitolul 8 - Pointerii inteligenti
  content_markdown: >
    
    În acest capitol vom demistifica pointerii inteligenți. Să explorăm aceste structuri de date care ne permit 
    să interacționăm cu cel mai de jos nivel al memoriei.

    Ferris spune: "Nu te simți copleșit de acest capitol dacă nu simți că poți scrie propriul tău cod de gestionare 
    a memoriei la nivel scăzut într-o singură lectură scurtă. Acest capitol are în principal rolul de a te introduce 
    în unele instrumente utile și de a-ți oferi o privire asupra modului în care funcționează!"
    
- title: Referințe revizuite
  content_markdown: >
    O referință este în principiu doar un număr care este poziția de început a unor octeți din memorie. 
    Singurul său scop este de a reprezenta conceptul unde există date de un anumit tip. 
    Ceea ce face o referință diferită de doar un număr este că Rust va valida durata de viață a referințelor nu durează 
    mai mult decât la care se referă (altfel am primi o eroare când am folosit-o!).

- title: Pointeri bruți
  content_markdown: >
    Referințele pot fi convertite într-un tip mai primitiv numit indicator brut. La fel ca un număr, acesta poate fi 
    copiat și mutat cu puține restricții. Rust nu oferă nicio asigurare cu privire la validitatea locației de memorie către care indică.

    Există două tipuri de indicatori bruti:

    * `*const T` - Un indicator brut către date de tip T care nu ar trebui să se schimbe niciodată.
    * `*mut T` - Un indicator brut către date de tip T care se pot modifica.
    Indicatoarele brute pot fi convertite în și din numere (de exemplu, `usize`).

    Indicatorii bruti pot accesa datele cu cod nesigur (mai multe despre asta mai târziu).

    Detalii de memorie:

    * O referință în Rust este foarte asemănătoare cu un pointer în C în ceea ce privește utilizarea, dar cu mult mai multe 
    restricții de timp de compilare privind modul în care poate fi stocată și mutată în alte funcții.
    * Un indicator brut din Rust este similar cu un indicator din C, deoarece reprezintă un număr care poate fi copiat sau 
    transmis și chiar transformat în tipuri numerice unde poate fi modificat ca număr pentru a face matematica indicatorului.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20memory_location%20%3D%20%26a%20as%20*const%20i32%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20is%20here%20%7B%7D%22%2C%20memory_location)%3B%0A%7D%0A

- title: Dereferențierea
  content_markdown: >
    Procesul de accesare/manipulare a datelor la care se face referire printr-o referință (adică &i32) se numește dereferencing.

    Referințele sunt folosite pentru a accesa/manipula datele în două moduri:

    Accesul la datele menționate în timpul atribuirii variabilelor.
    Acces la câmpuri sau metode ale datelor menționate.
    Rust are niște operatori puternici care ne permit să facem acest lucru.

- title: Operatorul *
  content_markdown: >
    Operatorul `*` este o modalitate explicită de a dereferi o referință.


        ```rust

        let a: i32 = 42;

        let ref_ref_ref_a: &&&i32 = &&&a;

        let ref_a: &i32 = **ref_ref_ref_a;

        let b: i32 = *ref_a;

        ```


        Detaliu de memorie:

        - Deoarece i32 este un tip primitiv care implementează trăsătura „Copy”,

        octeții variabilei `a` de pe stivă sunt copiați în octeții variabilei
        `b`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20i32%20%3D%2042%3B%0A%20%20%20%20let%20ref_ref_ref_a%3A%20%26%26%26i32%20%3D%20%26%26%26a%3B%0A%20%20%20%20let%20ref_a%3A%20%26i32%20%3D%20**ref_ref_ref_a%3B%0A%20%20%20%20let%20b%3A%20i32%20%3D%20*ref_a%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20b)%0A%7D
- title: Operatorul .
  content_markdown: >
    Operatorul `.` este utilizat în accesarea câmpurilor și metodelor unei referințe. Acesta 
    funcționează puțin mai subtil.
    
    
    
    ```rust

    let f = Foo { value: 42 };

    let ref_ref_ref_f = &&&f;

    println!("{}", ref_ref_ref_f.value);

    ```
    Woa, de ce nu a fost nevoie să adăugăm `***` înainte de `ref_ref_ref_f`? Aceasta este
        deoarece operatorul `.` dereferențiază automat.Ultima linie este transformată automat în următoarea de către compilator.
    
    
    ```rust

        println!("{}", (***ref_ref_ref_f).value);

    
    ```
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20value%3A%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20f%20%3D%20Foo%20%7B%20value%3A%2042%20%7D%3B%0A%20%20%20%20let%20ref_ref_ref_f%20%3D%20%26%26%26f%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20ref_ref_ref_f.value)%3B%0A%7D
- title: Pointerii inteligenti
  content_markdown: >
    În plus față de capacitatea de a crea referințe la datele tastate existente folosind
        operatorul `&`, Rust ne oferă capacitatea

        pentru a crea structuri * reference-like * referințe numite ** pointeri inteligenti **.


        Ne putem gândi la referințe la un nivel înalt ca la un tip care ne oferă acces la
        alt tip. Indicatoarele inteligente sunt diferite în ceea ce privește

        comportamentul de la referințe normale prin faptul că acestea funcționează pe baza logicii interne
        pe care le scrie un programator. Tu — programatorul — esti partea *inteligentă*.


        În mod obișnuit, pointerii inteligenti implementează trăsăturile „Deref”, „DerefMut” și „Drop” la
        specificați logica a ceea ce ar trebui să se întâmple când

        structura este dereferențiată cu operatorii `*` și `.`.
    code: >-
      https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aops%3A%3ADeref%3B%0Astruct%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20value%3A%20T%2C%0A%7D%0Aimpl%3CT%3E%20Deref%20for%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20was%20used!%22%2C%20std%3A%3Aany%3A%3Atype_name%3A%3A%3CT%3E())%3B%0A%20%20%20%20%20%20%20%20%26self.value%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20TattleTell%20%7B%0A%20%20%20%20%20%20%20%20value%3A%20%22secret%20message%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%2F%2F%20dereference%20occurs%20here%20immediately%20%0A%20%20%20%20%2F%2F%20after%20foo%20is%20auto-referenced%20for%20the%0A%20%20%20%20%2F%2F%20function%20%60len%60%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.len())%3B%0A%7D%0A
- title: Cod nesigur inteligent
  content_markdown: >
    Pointerii inteligenti tind să folosească cod *nesigur* destul de des. După cum se menționa
    mai devreme,
  
    sunt instrumente comune pentru interacțiunea cu cele mai scăzute niveluri de memorie în
    Rugini.
    
    
    Ce este un cod nesigur? Codul nesigur se comportă exact ca Rust normal cu
    cu excepţia câtorva abilităţi care
    
    compilatorul Rust nu poate oferi garanții despre.
    
    
    O abilitate principală a codului nesigur este *dereferențiarea unui pointer brut*. Acea
    înseamnă a lua un *pointer brut*
    
    la o poziție în memorie și declarând „o structură de date există aici!” și
    transformându-l într-o reprezentare a datelor pe care le puteți utiliza (adică `*const u8` în
    `u8`).
    
    Rust nu are nicio modalitate de a urmări semnificația fiecărui octet care este scris
    la memorie. Pentru că Rust nu poate
    
    garanta despre ceea ce există la un număr arbitrar folosit ca *pointer brut*,
    pune dereferința într-un bloc `nesigur { ... }`.
    
    
    Pointerii inteligenti *dereferențiază pointerii bruti* extensiv, dar sunt bine
    dovediti în ceea ce fac.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%5Bu8%3B%204%5D%20%3D%20%5B86%2C%2014%2C%2073%2C%2064%5D%3B%0A%20%20%20%20%2F%2F%20this%20is%20a%20raw%20pointer.%20Getting%20the%20memory%20address%0A%20%20%20%20%2F%2F%20of%20something%20as%20a%20number%20is%20totally%20safe%0A%20%20%20%20let%20pointer_a%20%3D%20%26a%20as%20*const%20u8%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20memory%20location%3A%20%7B%7D%22%2C%20pointer_a)%3B%0A%20%20%20%20%2F%2F%20Turning%20our%20number%20into%20a%20raw%20pointer%20to%20a%20f32%20is%0A%20%20%20%20%2F%2F%20also%20safe%20to%20do.%0A%20%20%20%20let%20pointer_b%20%3D%20pointer_a%20as%20*const%20f32%3B%0A%20%20%20%20let%20b%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20is%20unsafe%20because%20we%20are%20telling%20the%20compiler%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20assume%20our%20pointer%20is%20a%20valid%20f32%20and%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it's%20value%20into%20the%20variable%20b.%0A%20%20%20%20%20%20%20%20%2F%2F%20Rust%20has%20no%20way%20to%20verify%20this%20assumption%20is%20true.%0A%20%20%20%20%20%20%20%20*pointer_b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22I%20swear%20this%20is%20a%20pie!%20%7B%7D%22%2C%20b)%3B%0A%7D%0A
- title: Prietenii familiari
  content_markdown: >
    Luați în considerare câțiva pointeri inteligenti pe care i-am văzut deja, cum ar fi `Vec<T>` și `String`.
    
    `Vec<T>` este un pointer inteligent care ține doar unele regiuni de memorie.Compilatorul Rust nu are idee ce există
    în acești octeți. Indicatorul inteligent interpretează ce înseamnă să apuci
        elemente din regiunea de memorie pe care o gestionează,

        ține evidența unde încep și se termină structurile de date din acești octeți și
        apoi în cele din urmă dereferențiază un pointer brut

        în structuri de date într-o interfață ergonomică și curată pe care să o folosim
        (de exemplu, `my_vec[3]`).


        În mod similar, `String` ține evidența unei regiuni de memorie de octeți și
        restricționează programatic conținutul scris pe acesta la întotdeauna

        să fie valid `utf-8` și ajută la dereferința acelei regiuni de memorie într-un tip
        `&str`.


        Ambele aceste structuri de date folosesc dereferențiarea nesigură a indicatorilor bruti pentru a face
        munca lor.


        Detaliu de memorie:

        * Rust are un echivalent al  `malloc`-ului din C folosind
        [alloc](https://doc.rust-lang.org/std/alloc/fn.alloc.html) și
        [Layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html) pentru
        obținerea propriilor regiuni de memorie de gestionat.
    code: >-
      https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aalloc%3A%3A%7Balloc%2C%20Layout%7D%3B%0Ause%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20secret_recipe%3A%20usize%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20let's%20ask%20for%204%20bytes%0A%20%20%20%20%20%20%20%20let%20layout%20%3D%20Layout%3A%3Afrom_size_align(4%2C%201).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20allocate%20and%20save%20the%20memory%20location%20as%20a%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20alloc(layout)%20as%20*mut%20u8%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20use%20pointer%20math%20and%20write%20a%20few%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20u8%20values%20to%20memory%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.write(86)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(1).write(14)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(2).write(73)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(3).write(64)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Pie%20%7B%20secret_recipe%3A%20ptr%20as%20usize%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Deref%20for%20Pie%20%7B%0A%20%20%20%20type%20Target%20%3D%20f32%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26f32%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20interpret%20secret_recipe%20pointer%20as%20a%20f32%20raw%20pointer%0A%20%20%20%20%20%20%20%20let%20pointer%20%3D%20self.secret_recipe%20as%20*const%20f32%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it%20into%20a%20return%20value%20%26f32%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26*pointer%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p%20%3D%20Pie%3A%3Anew()%3B%0A%20%20%20%20%2F%2F%20%22make%20a%20pie%22%20by%20dereferencing%20our%20%0A%20%20%20%20%2F%2F%20Pie%20struct%20smart%20pointer%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20*p)%3B%0A%7D%0A
- title: Memorie alocată in heap
  content_markdown: >
    `Box` este un pointer inteligent care ne permite să mutăm datele din stivă în heap.


    Dereferențiarea ne permite să folosim datele alocate în mod ergonomic ca și cum ar fi 
    fost tipul original.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%7D%0A
- title: Main-ul esuabil revizitat
  content_markdown: >
    Codul Rust poate avea o multitudine de reprezentări ale erorilor, dar biblioteca
        standard are

        o trăsătură universală `std::error::Error` pentru descrierea erorilor.


        Folosind un pointer inteligent `Box` putem folosi tipul `Box<dyn std::error::Error>`
        ca tip comun pentru returnarea erorilor, deoarece ne permite să

        propagăm o eroare pe heap și să interacționăm cu ea la un nivel înalt
        fără a fi nevoie să cunoască un anumit tip.


        La începutul lui Tour of Rust am aflat că main-ul poate returna o eroare. Putem acum sa returnăm

        un tip capabil să descrie aproape orice fel de eroare care ar putea apărea în
        programul nostru

        atâta timp cât structura de date a erorii implementează trăsătura comună „Error” comună a lui Rust.


        ```rust

        fn main() -> Rezultat<(), Box<dyn std::error:Error>>

        ```
    code: >-
      https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Afmt%3A%3ADisplay%3B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0A%0Astruct%20Pie%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20NotFreshError%3B%0A%0Aimpl%20Display%20for%20NotFreshError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20std%3A%3Afmt%3A%3AFormatter%3C%27_%3E)%20-%3E%20std%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22This%20pie%20is%20not%20fresh!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Error%20for%20NotFreshError%20%7B%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20Err(Box%3A%3Anew(NotFreshError))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3F%3B%0A%20%20%20%20Ok(())%0A%7D%0A
- title: Numărarea referințelor
  content_markdown: > 
    `Rc` este un pointer inteligent care mută datele din stivă pe heap. Aceasta
    ne permite
    
    să clonăm alți pointeri inteligenți `Rc` care au toate capacitatea de a fi imutabili
    împrumutați datele
    
    care a fost pus pe grămadă.
    
    
    Numai atunci când ultimul pointer inteligent este aruncat, datele din heap devin
    dealocate.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Rc%3A%3Anew(Pie)%3B%0A%20%20%20%20let%20heap_pie2%20%3D%20heap_pie.clone()%3B%0A%20%20%20%20let%20heap_pie3%20%3D%20heap_pie2.clone()%3B%0A%0A%20%20%20%20heap_pie3.eat()%3B%0A%20%20%20%20heap_pie2.eat()%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%0A%20%20%20%20%2F%2F%20all%20reference%20count%20smart%20pointers%20are%20dropped%20now%0A%20%20%20%20%2F%2F%20the%20heap%20data%20Pie%20finally%20deallocates%0A%7D%0A
- title: Distribuirea adreselor
  content_markdown: >
    `RefCell` este o structură de date container deținută în mod obișnuit de pointerii inteligenți care
        preiau date și ne lasă să

        împrumută referințe mutabile și imutabile la ceea ce se află în interior. Previne 
        împrumut de la a

        fii abuzat prin aplicarea regulilor de siguranță a memoriei Rust în timpul execuției atunci când solicităm
        imprumutul

        datelor din:


        **Doar o referință mutabilă SAU mai multe referințe imutabile, dar nu
        ambii!**


        Dacă încalci aceste reguli, „RefCell” va intra în panică.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22only%20I%20eat%20the%20pie%20right%20now!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mutex_pie%20%3D%20Mutex%3A%3Anew(Pie)%3B%0A%20%20%20%20%2F%2F%20let's%20borrow%20a%20locked%20immutable%20reference%20of%20pie%0A%20%20%20%20%2F%2F%20we%20have%20to%20unwrap%20the%20result%20of%20a%20lock%0A%20%20%20%20%2F%2F%20because%20it%20might%20fail%0A%20%20%20%20let%20ref_pie%20%3D%20mutex_pie.lock().unwrap()%3B%0A%20%20%20%20ref_pie.eat()%3B%0A%20%20%20%20%2F%2F%20locked%20reference%20drops%20here%2C%20and%20mutex%20protected%20value%20can%20be%20used%20by%20someone%20else%0A%7D%0A
- title: Distribuirea in threads
  content_markdown: >
    `Mutex` este o structură de date container deținută în mod obișnuit de pointeri inteligenți care
        preiau date și ne permite să împrumutăm referințe mutabile

        și imutabile la datele din interior. Acest lucru împiedică împrumutul de la a
        fii abuzat ,

        prin a avea sistemul de operare să restricționeze doar un thread CPU să aibă
        acces la date,

        blocarea altor threaduri până când acel thread original este gata cu 
        imprumutul blocat.


        Multithreading este dincolo de scopul Tour of Rust, dar `Mutex` este un
        parte fundamentală a orchestrarii

        mai multe threaduri CPU care accesează aceleași date.


        Există un indicator inteligent special `Arc` care este identic cu `Rc`, cu excepția că
        folosește creșterea în siguranță a numărului de referințe.

        Este adesea folosit pentru a avea multe referințe la același „Mutex”.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22only%20I%20eat%20the%20pie%20right%20now!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mutex_pie%20%3D%20Mutex%3A%3Anew(Pie)%3B%0A%20%20%20%20%2F%2F%20let's%20borrow%20a%20locked%20immutable%20reference%20of%20pie%0A%20%20%20%20%2F%2F%20we%20have%20to%20unwrap%20the%20result%20of%20a%20lock%0A%20%20%20%20%2F%2F%20because%20it%20might%20fail%0A%20%20%20%20let%20ref_pie%20%3D%20mutex_pie.lock().unwrap()%3B%0A%20%20%20%20ref_pie.eat()%3B%0A%20%20%20%20%2F%2F%20locked%20reference%20drops%20here%2C%20and%20mutex%20protected%20value%20can%20be%20used%20by%20someone%20else%0A%7D%0A
- title: Combinarea pointerilor inteligenți
  content_markdown: >
    Pointerii inteligenți pot părea limitați, dar pot face niște combinații foarte puternice.

    `Rc<Vec<Foo>>` - Permite clonarea mai multor pointeri inteligente care pot împrumuta același vector de structuri de date imutabile pe heap.

    `Rc<RefCell<Foo>>` - Permite mai multor pointeri inteligenți abilitatea de a împrumuta în mod mutabil/imutabil aceeași structură Foo

    `Arc<Mutex<Foo>>` - Permite mai multor pointeri inteligente abilitatea de a bloca împrumuturi temporare mutabile/imuabile într-un mod exclusiv al unui fir CPU.

    Detaliu de memorie:

    * Veți observa o temă cu multe dintre aceste combinații. Utilizarea unui tip de date imutabil (posibil deținut de mai mulți pointeri inteligenți) 
    pentru a modifica datele interne. Acesta este denumit ca modelul de „mutabilitate interioară” în Rust. Este un tipar 
    care ne permite să îndoim regulile de utilizare a memoriei în timpul execuției, cu același nivel de siguranță ca și 
    verificările lui Rust la timp de compilare.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat_slice(%26mut%20self%2C%20name%3A%20%26str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20took%20a%20slice!%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20pie%3A%20Rc%3CRefCell%3CPie%3E%3E%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20use%20smart%20pointer%20to%20pie%20for%20a%20mutable%20borrow%0A%20%20%20%20%20%20%20%20let%20mut%20p%20%3D%20self.pie.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20take%20a%20bite!%0A%20%20%20%20%20%20%20%20p.eat_slice(%26self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pie%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Pie%20%7B%20slices%3A%208%20%7D))%3B%0A%20%20%20%20%2F%2F%20ferris%20and%20sarah%20are%20given%20clones%20of%20smart%20pointer%20to%20pie%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22ferris%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22sarah%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20ferris.eat()%3B%0A%20%20%20%20sarah.eat()%3B%0A%0A%20%20%20%20let%20p%20%3D%20pie.borrow()%3B%0A%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2C%20p.slices)%3B%0A%7D%0A
- title: Concluzii
  content_markdown: >
    Pointerii inteligenți sunt expresiile de programare Rust și ne permite să nu recreem
    modele foarte comune de utilizare a memoriei. Cu ele sunteți gata să abordați
    cel mai dificile
    
    provocări! Acum că avem bazele Rust, hai să vorbim puțin despre
    cum facem
    
    proiecte mai mari. În capitolul 9 ne eliberăm de o singură pagină de
    
    linii de cod.
    
